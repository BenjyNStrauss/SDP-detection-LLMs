/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.camel.processor;

import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ScheduledExecutorService;

import org.apache.camel.AsyncCallback;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Traceable;
import org.apache.camel.spi.IdAware;
import org.apache.camel.spi.RouteIdAware;
import org.apache.camel.support.AsyncProcessorSupport;
import org.apache.camel.util.ObjectHelper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public abstract class AbstractThrottler extends AsyncProcessorSupport implements Traceable, IdAware, RouteIdAware, Throttler {
    private static final Logger LOG = LoggerFactory.getLogger(AbstractThrottler.class);

    protected static final String DEFAULT_KEY = "CamelThrottlerDefaultKey";
    protected static final String PROPERTY_EXCHANGE_QUEUED_TIMESTAMP = "CamelThrottlerExchangeQueuedTimestamp";
    protected static final String PROPERTY_EXCHANGE_STATE = "CamelThrottlerExchangeState";
    protected final ScheduledExecutorService asyncExecutor;
    protected final boolean shutdownAsyncExecutor;
    protected final CamelContext camelContext;
    protected final Expression correlationExpression;
    protected String id;
    protected String routeId;
    protected boolean rejectExecution;
    protected boolean asyncDelayed;
    protected boolean callerRunsWhenRejected = true;
    protected Expression maxRequestsExpression;

    AbstractThrottler(final ScheduledExecutorService asyncExecutor, final boolean shutdownAsyncExecutor,
                      final CamelContext camelContext, final boolean rejectExecution, Expression correlation,
                      final Expression maxRequestsExpression) {
        this.asyncExecutor = asyncExecutor;
        this.shutdownAsyncExecutor = shutdownAsyncExecutor;
        this.camelContext = camelContext;
        this.rejectExecution = rejectExecution;
        this.correlationExpression = correlation;
        this.maxRequestsExpression = ObjectHelper.notNull(maxRequestsExpression, "maxConcurrentRequestsExpression");
    }

    protected static boolean handleInterrupt(
            Exchange exchange, AsyncCallback callback, InterruptedException e, boolean doneSync) {
        // determine if we can still run, or the camel context is forcing a shutdown
        boolean forceShutdown = exchange.getContext().getShutdownStrategy().isForceShutdown();
        if (forceShutdown) {
            String msg = "Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: "
                         + exchange;
            LOG.debug(msg);
            exchange.setException(new RejectedExecutionException(msg, e));
        } else {
            exchange.setException(e);
        }
        callback.done(doneSync);
        return doneSync;
    }

    protected static boolean handleException(Exchange exchange, AsyncCallback callback, Exception t, boolean doneSync) {
        exchange.setException(t);
        callback.done(doneSync);
        return doneSync;
    }

    @Override
    public boolean isRejectExecution() {
        return rejectExecution;
    }

    public void setRejectExecution(boolean rejectExecution) {
        this.rejectExecution = rejectExecution;
    }

    @Override
    public boolean isAsyncDelayed() {
        return asyncDelayed;
    }

    public void setAsyncDelayed(boolean asyncDelayed) {
        this.asyncDelayed = asyncDelayed;
    }

    @Override
    public String getId() {
        return id;
    }

    @Override
    public void setId(final String id) {
        this.id = id;
    }

    @Override
    public String getRouteId() {
        return routeId;
    }

    @Override
    public void setRouteId(String routeId) {
        this.routeId = routeId;
    }

    @Override
    public boolean isCallerRunsWhenRejected() {
        return callerRunsWhenRejected;
    }

    public void setCallerRunsWhenRejected(boolean callerRunsWhenRejected) {
        this.callerRunsWhenRejected = callerRunsWhenRejected;
    }

    /**
     * Sets the maximum number of concurrent requests.
     */
    @Override
    public void setMaximumRequestsExpression(Expression maxConcurrentRequestsExpression) {
        this.maxRequestsExpression = maxConcurrentRequestsExpression;
    }

    public Expression getMaximumRequestsExpression() {
        return maxRequestsExpression;
    }

    protected enum State {
        SYNC,
        ASYNC,
        ASYNC_REJECTED
    }

    @Override
    public abstract String getMode();
}
<<<<<<<<DIVIDER>>>>>>>>
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;

import org.slf4j.LoggerFactory;

/**
 * A strategy for aggregating two exchanges together into a single exchange.
 * <p/>
 * On the first invocation of the {@link #aggregate(org.apache.camel.Exchange, org.apache.camel.Exchange) aggregate}
 * method the <tt>oldExchange</tt> parameter is <tt>null</tt>. The reason is that we have not aggregated anything yet.
 * So its only the <tt>newExchange</tt> that has a value. Usually you just return the <tt>newExchange</tt> in this
 * situation. But you still have the power to decide what to do, for example you can do some alternation on the exchange
 * or remove some headers. And a more common use case is for instance to count some values from the body payload. That
 * could be to sum up a total amount etc.
 * <p/>
 * Note that <tt>oldExchange</tt> may be <tt>null</tt> more than once when this strategy is throwing a
 * {@link java.lang.RuntimeException} and <tt>parallelProcessing</tt> is used. You can work around this behavior using
 * the <tt>stopOnAggregateException</tt> option.
 * <p/>
 * It is possible that <tt>newExchange</tt> is <tt>null</tt> which could happen if there was no data possible to
 * acquire. Such as when using a <tt>PollEnricher</tt> to poll from a JMS queue which is empty and a timeout was set.
 * <p/>
 * Important: In the aggregate method, do not create a new exchange instance to return, instead return either the old or
 * new exchange from the input parameters; favor returning the old exchange whenever possible.
 * <p/>
 * Possible implementations include performing some kind of combining or delta processing, such as adding line items
 * together into an invoice or just using the newest exchange and removing old exchanges such as for state tracking or
 * market data prices; where old values are of little use.
 * <p/>
 * If an implementation also implements {@link org.apache.camel.Service} then any
 * <a href="http://camel.apache.org/eip">EIP</a> that allowing configuring a {@link AggregationStrategy} will invoke the
 * {@link org.apache.camel.Service#start()} and {@link org.apache.camel.Service#stop()} to control the lifecycle aligned
 * with the EIP itself.
 * <p/>
 * If an implementation also implements {@link org.apache.camel.CamelContextAware} then any
 * <a href="http://camel.apache.org/eip">EIP</a> that allowing configuring a {@link AggregationStrategy} will inject the
 * {@link org.apache.camel.CamelContext} prior to using the aggregation strategy.
 */
public interface AggregationStrategy {

    /**
     * Aggregates an old and new exchange together to create a single combined exchange
     * <p/>
     * Important: In the aggregate method, do not create a new exchange instance to return, instead return either the
     * old or new exchange from the input parameters; favor returning the old exchange whenever possible.
     *
     * @param  oldExchange the oldest exchange (is <tt>null</tt> on first aggregation as we only have the new exchange)
     * @param  newExchange the newest exchange (can be <tt>null</tt> if there was no data possible to acquire)
     * @return             a combined composite of the two exchanges, return either the old or new exchange from the
     *                     input parameters; favor returning the old exchange whenever possible)
     */
    Exchange aggregate(Exchange oldExchange, Exchange newExchange);

    /**
     * Aggregates an old and new exchange together to create a single combined exchange.
     * <p/>
     * Important: In the aggregate method, do not create a new exchange instance to return, instead return either the
     * old or new exchange from the input parameters; favor returning the old exchange whenever possible.
     * <p/>
     * Important: Only Multicast, Recipient List, and Splitter EIP supports this method with access to the input
     * exchange. All other EIPs does not and uses the {@link #aggregate(Exchange, Exchange)} method instead.
     *
     * @param  oldExchange   the oldest exchange (is <tt>null</tt> on first aggregation as we only have the new
     *                       exchange)
     * @param  newExchange   the newest exchange (can be <tt>null</tt> if there was no data possible to acquire)
     * @param  inputExchange the input exchange (input to the EIP)
     * @return               a combined composite of the two exchanges, return either the old or new exchange from the
     *                       input parameters; favor returning the old exchange whenever possible)
     */
    default Exchange aggregate(Exchange oldExchange, Exchange newExchange, Exchange inputExchange) {
        return aggregate(oldExchange, newExchange);
    }

    /**
     * Indicates if this aggregation strategy uses pre-completion mode.
     *
     * @return <tt>true</tt> if this strategy uses pre-completion mode, or <tt>false</tt> otherwise.
     */
    default boolean canPreComplete() {
        return false;
    }

    /**
     * Determines if the aggregation should complete the current group, and start a new group, or the aggregation should
     * continue using the current group. This callback will only be called if {@link #canPreComplete()} returns
     * <tt>true</tt>.
     *
     * @param  oldExchange the oldest exchange (is <tt>null</tt> on first aggregation as we only have the new exchange)
     * @param  newExchange the newest exchange (can be <tt>null</tt> if there was no data possible to acquire)
     * @return             <tt>true</tt> to complete current group and start a new group, or <tt>false</tt> to keep
     *                     using current
     */
    default boolean preComplete(Exchange oldExchange, Exchange newExchange) {
        return false;
    }

    /**
     * The aggregated {@link Exchange} has completed
     *
     * <b>Important: </b> This method must <b>not</b> throw any exceptions.
     *
     * @param exchange the current aggregated exchange, or the original {@link org.apache.camel.Exchange} if no
     *                 aggregation has been done before the completion occurred
     */
    default void onCompletion(Exchange exchange) {
    }

    /**
     * The aggregated {@link Exchange} has completed
     *
     * <b>Important: </b> This method must <b>not</b> throw any exceptions.
     *
     * @param exchange      the current aggregated exchange, or the original {@link org.apache.camel.Exchange} if no
     *                      aggregation has been done before the completion occurred
     * @param inputExchange the input exchange (input to the EIP)
     */
    default void onCompletion(Exchange exchange, Exchange inputExchange) {
        onCompletion(exchange);
    }

    /**
     * A timeout occurred.
     * <p/>
     * <b>Important: </b> This method must <b>not</b> throw any exceptions.
     *
     * @param exchange the current aggregated exchange, or the original {@link Exchange} if no aggregation has been done
     *                 before the timeout occurred
     * @param index    the index, may be <tt>-1</tt> if not possible to determine the index
     * @param total    the total, may be <tt>-1</tt> if not possible to determine the total
     * @param timeout  the timeout value in millis, may be <tt>-1</tt> if not possible to determine the timeout
     */
    default void timeout(Exchange exchange, int index, int total, long timeout) {
    }

    /**
     * Callback when the aggregated {@link Exchange} fails to add in the
     * {@link org.apache.camel.spi.OptimisticLockingAggregationRepository} because of an
     * {@link org.apache.camel.spi.OptimisticLockingAggregationRepository.OptimisticLockingException}.
     * <p/>
     * Please note that when aggregating {@link Exchange}'s to be careful not to modify and return the
     * {@code oldExchange} from the
     * {@link AggregationStrategy#aggregate(org.apache.camel.Exchange, org.apache.camel.Exchange)} method. If you are
     * using the default MemoryAggregationRepository this will mean you have modified the value of an object already
     * referenced/stored by the MemoryAggregationRepository. This makes it impossible for optimistic locking to work
     * correctly with the MemoryAggregationRepository.
     * <p/>
     * You should instead return either the new {@code newExchange} or a completely new instance of {@link Exchange}.
     * This is due to the nature of how the underlying {@link java.util.concurrent.ConcurrentHashMap} performs CAS
     * operations on the value identity.
     *
     * @see java.util.concurrent.ConcurrentHashMap
     */
    default void onOptimisticLockFailure(Exchange oldExchange, Exchange newExchange) {
        LoggerFactory.getLogger(getClass()).trace(
                "onOptimisticLockFailure with AggregationStrategy: {}, oldExchange: {}, newExchange: {}", this, oldExchange,
                newExchange);
    }

}
<<<<<<<<DIVIDER>>>>>>>>
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregator;

import java.util.ArrayList;
import java.util.List;

import jakarta.xml.bind.annotation.XmlRootElement;

import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.AggregationStrategies;
import org.apache.camel.builder.RouteBuilder;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class AggregationStrategyBeanAdapterAllowNullTest extends ContextTestSupport {

    private final MyUserAppender appender = new MyUserAppender();

    @Test
    public void testAggregate() throws Exception {
        getMockEndpoint("mock:result").expectedMessageCount(1);

        template.sendBody("direct:start", new User("Claus"));
        template.sendBody("direct:start", new User("James"));
        template.sendBody("direct:start", new User("Jonathan"));

        assertMockEndpointsSatisfied();

        List<?> names = getMockEndpoint("mock:result").getReceivedExchanges().get(0).getIn().getBody(List.class);
        assertEquals("Claus", names.get(0));
        assertEquals("James", names.get(1));
        assertEquals("Jonathan", names.get(2));
    }

    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            @Override
            public void configure() {
                from("direct:start").aggregate(constant(true), AggregationStrategies.beanAllowNull(appender, "addUsers"))
                        .completionSize(3).to("mock:result");
            }
        };
    }

    public static final class MyUserAppender {

        public List<String> addUsers(List<String> names, User user) {
            if (names == null) {
                names = new ArrayList<>();
            }
            names.add(user.getName());
            return names;
        }
    }

    /**
     * We support annotations on the types.
     */
    @XmlRootElement(name = "user")
    public static final class User {
        private final String name;

        public User(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }
    }

}
<<<<<<<<DIVIDER>>>>>>>>
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;

import org.apache.camel.CamelContext;
import org.apache.camel.ErrorHandlerFactory;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.model.DataFormatDefinition;
import org.apache.camel.model.ProcessorDefinition;
import org.apache.camel.model.errorhandler.DefaultErrorHandlerDefinition;
import org.apache.camel.model.language.ExpressionDefinition;
import org.apache.camel.model.transformer.TransformerDefinition;
import org.apache.camel.model.validator.ValidatorDefinition;
import org.apache.camel.reifier.RouteReifier;
import org.apache.camel.reifier.dataformat.DataFormatReifier;
import org.apache.camel.reifier.errorhandler.ErrorHandlerReifier;
import org.apache.camel.reifier.language.ExpressionReifier;
import org.apache.camel.reifier.transformer.TransformerReifier;
import org.apache.camel.reifier.validator.ValidatorReifier;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.spi.ModelReifierFactory;
import org.apache.camel.spi.Transformer;
import org.apache.camel.spi.Validator;

/**
 * Default {@link ModelReifierFactory}
 */
public class DefaultModelReifierFactory implements ModelReifierFactory {

    @Override
    public Route createRoute(CamelContext camelContext, Object routeDefinition) {
        return new RouteReifier(camelContext, (ProcessorDefinition<?>) routeDefinition).createRoute();
    }

    @Override
    public DataFormat createDataFormat(CamelContext camelContext, Object dataFormatDefinition) {
        return DataFormatReifier.reifier(camelContext, (DataFormatDefinition) dataFormatDefinition).createDataFormat();
    }

    @Override
    public Processor createErrorHandler(Route route, Processor processor) throws Exception {
        return createErrorHandler(route, route.getErrorHandlerFactory(), processor);
    }

    @Override
    public Processor createErrorHandler(Route route, ErrorHandlerFactory errorHandlerFactory, Processor processor)
            throws Exception {
        return ErrorHandlerReifier.reifier(route, errorHandlerFactory).createErrorHandler(processor);
    }

    @Override
    public ErrorHandlerFactory createDefaultErrorHandler() {
        return new DefaultErrorHandlerDefinition();
    }

    @Override
    public Expression createExpression(CamelContext camelContext, Object expressionDefinition) {
        return ExpressionReifier.reifier(camelContext, (ExpressionDefinition) expressionDefinition).createExpression();
    }

    @Override
    public Predicate createPredicate(CamelContext camelContext, Object expressionDefinition) {
        return ExpressionReifier.reifier(camelContext, (ExpressionDefinition) expressionDefinition).createPredicate();
    }

    @Override
    public Transformer createTransformer(CamelContext camelContext, Object transformerDefinition) {
        return TransformerReifier.reifier(camelContext, (TransformerDefinition) transformerDefinition).createTransformer();
    }

    @Override
    public Validator createValidator(CamelContext camelContext, Object transformerDefinition) {
        return ValidatorReifier.reifier(camelContext, (ValidatorDefinition) transformerDefinition).createValidator();
    }
}
<<<<<<<<DIVIDER>>>>>>>>
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;

import java.io.IOException;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.ExecutorService;

import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Expression;
import org.apache.camel.LineNumberAware;
import org.apache.camel.NamedNode;
import org.apache.camel.NoFactoryAvailableException;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.spi.BootstrapCloseable;
import org.apache.camel.spi.FactoryFinder;
import org.apache.camel.spi.ProcessorFactory;
import org.apache.camel.spi.annotations.JdkService;
import org.apache.camel.support.PluginHelper;

/**
 * Default {@link ProcessorFactory} that supports using 3rd party Camel components to implement the EIP
 * {@link Processor}.
 * <p/>
 * The component should use the {@link FactoryFinder} SPI to specify a file with the name of the EIP model in the
 * directory of {@link #RESOURCE_PATH}. The file should contain a property with key <tt>class</tt> that refers to the
 * name of the {@link ProcessorFactory} the Camel component implement, which gets called for creating the
 * {@link Processor}s for the EIP.
 * <p/>
 */
@JdkService(ProcessorFactory.FACTORY)
public class DefaultProcessorFactory implements ProcessorFactory, BootstrapCloseable {

    public static final String RESOURCE_PATH = "META-INF/services/org/apache/camel/model/";

    private FactoryFinder finder;

    @Override
    public void close() throws IOException {
        if (finder instanceof BootstrapCloseable bootstrapCloseable) {
            bootstrapCloseable.close();
            finder = null;
        }
    }

    @Override
    public Processor createChildProcessor(Route route, NamedNode definition, boolean mandatory) throws Exception {
        String name = definition.getClass().getSimpleName();
        if (finder == null) {
            finder = PluginHelper.getFactoryFinderResolver(route.getCamelContext())
                    .resolveBootstrapFactoryFinder(route.getCamelContext().getClassResolver(), RESOURCE_PATH);
        }
        try {
            Object object = finder.newInstance(name).orElse(null);
            if (object instanceof ProcessorFactory pc) {
                Processor processor = pc.createChildProcessor(route, definition, mandatory);
                LineNumberAware.trySetLineNumberAware(processor, definition);
                return processor;
            }
        } catch (NoFactoryAvailableException e) {
            // ignore there is no custom factory
        }

        return null;
    }

    @Override
    public Processor createProcessor(Route route, NamedNode definition) throws Exception {
        String name = definition.getClass().getSimpleName();
        if (finder == null) {
            finder = PluginHelper.getFactoryFinderResolver(route.getCamelContext())
                    .resolveBootstrapFactoryFinder(route.getCamelContext().getClassResolver(), RESOURCE_PATH);
        }
        ProcessorFactory pc = finder.newInstance(name, ProcessorFactory.class).orElse(null);
        if (pc != null) {
            Processor processor = pc.createProcessor(route, definition);
            LineNumberAware.trySetLineNumberAware(processor, definition);
            return processor;
        }
        return null;
    }

    @Override
    @SuppressWarnings("unchecked")
    public Processor createProcessor(CamelContext camelContext, String definitionName, Object[] args)
            throws Exception {
        if ("SendDynamicProcessor".equals(definitionName)) {
            String uri = (String) args[0];
            Expression expression = (Expression) args[1];
            ExchangePattern exchangePattern = (ExchangePattern) args[2];
            SendDynamicProcessor processor = new SendDynamicProcessor(uri, expression);
            processor.setCamelContext(camelContext);
            if (exchangePattern != null) {
                processor.setPattern(exchangePattern);
            }
            return processor;
        } else if ("MulticastProcessor".equals(definitionName)) {
            Collection<Processor> processors = (Collection<Processor>) args[0];
            ExecutorService executor = (ExecutorService) args[1];
            boolean shutdownExecutorService = (boolean) args[2];
            return new MulticastProcessor(
                    camelContext, null, processors, null, true, executor, shutdownExecutorService, false, false, 0,
                    null, false, false, 0);
        } else if ("Pipeline".equals(definitionName)) {
            List<Processor> processors = (List<Processor>) args[0];
            return Pipeline.newInstance(camelContext, processors);
        }

        return null;
    }
}
<<<<<<<<DIVIDER>>>>>>>>
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.properties;

import org.apache.camel.spi.PropertiesSource;
import org.apache.camel.spi.PropertiesSourceFactory;

public class DefaultPropertiesSourceFactory implements PropertiesSourceFactory {

    private final PropertiesComponent pc;

    public DefaultPropertiesSourceFactory(PropertiesComponent pc) {
        this.pc = pc;
    }

    @Override
    public PropertiesSource newFilePropertiesSource(String location) {
        return new FilePropertiesSource(pc, new PropertiesLocation("file", location));
    }

    @Override
    public PropertiesSource newClasspathPropertiesSource(String location) {
        return new ClasspathPropertiesSource(pc, new PropertiesLocation("classpath", location));
    }

    @Override
    public PropertiesSource newRefPropertiesSource(String ref) {
        return new RefPropertiesSource(pc, new PropertiesLocation("ref", ref));
    }
}
<<<<<<<<DIVIDER>>>>>>>>
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.tooling.util;

import static org.apache.camel.tooling.util.Strings.isNullOrEmpty;

public final class JavadocHelper {

    private static final String VALID_CHARS = ".,-='/\\!&%():;#${}";

    private JavadocHelper() {
    }

    /**
     * Sanitizes the javadoc to removed invalid characters so it can be used as json description
     *
     * @param  javadoc the javadoc
     * @return         the text that is valid as json
     */
    public static String sanitizeDescription(String javadoc, boolean summary) {
        if (isNullOrEmpty(javadoc)) {
            return null;
        }

        // lets just use what java accepts as identifiers
        StringBuilder sb = new StringBuilder(javadoc.length());

        // split into lines
        String[] lines = javadoc.split("\n");

        boolean first = true;
        for (String line : lines) {
            line = line.trim();

            if (line.startsWith("**")) {
                continue;
            }
            // remove leading javadoc *
            if (line.startsWith("*")) {
                line = line.substring(1);
                line = line.trim();
            }

            // terminate if we reach @param, @return or @deprecated as we only want the javadoc summary
            if (line.startsWith("@param") || line.startsWith("@return") || line.startsWith("@deprecated")) {
                break;
            }

            // skip lines that are javadoc references
            if (line.startsWith("@")) {
                continue;
            }

            // we are starting from a new line, so add a whitespace
            if (!first) {
                sb.append(' ');
            }

            // append data
            String s = line.trim();
            sb.append(s);

            boolean empty = isNullOrEmpty(s);
            boolean endWithDot = s.endsWith(".");
            boolean haveText = !sb.isEmpty();

            if (haveText && summary && (empty || endWithDot)) {
                // if we only want a summary, then skip at first empty line we encounter, or if the sentence ends with a dot
                break;
            }

            first = false;
        }

        String s = sb.toString();
        // remove all XML tags
        s = s.replaceAll("<.*?>", "");
        // remove {@link inlined javadoc links which is special handled
        s = s.replaceAll("\\{@link\\s\\w+\\s(\\w+)}", "$1");
        s = s.replaceAll("\\{@link\\s([\\w]+)}", "$1");
        // also remove the commonly mistake to do with @{link
        s = s.replaceAll("@\\{link\\s\\w+\\s(\\w+)}", "$1");
        s = s.replaceAll("@\\{link\\s([\\w]+)}", "$1");

        // remove all inlined javadoc links, eg such as {@link org.apache.camel.spi.Registry}
        // use #? to remove leading # in case its a local reference
        s = s.replaceAll("\\{@\\w+\\s#?([\\w.#(\\d,)]+)}", "$1");

        // create a new line
        StringBuilder cb = new StringBuilder(s.length() + 16);
        for (char c : s.toCharArray()) {
            if (Character.isJavaIdentifierPart(c) || VALID_CHARS.indexOf(c) != -1) {
                cb.append(c);
            } else if (Character.isWhitespace(c)) {
                // always use space as whitespace, also for line feeds etc
                cb.append(' ');
            }
        }
        s = cb.toString();

        // remove double whitespaces, and trim
        s = s.replaceAll("\\s+", " ");
        // unescape http links
        s = s.replaceAll("\\\\(http:|https:)", "$1");
        return s.trim();
    }

    /**
     * Encodes the text into safe XML by replacing &lt; $gt; and &amp; with XML tokens
     *
     * @param  text the text
     * @return      the encoded text
     */
    public static String xmlEncode(String text) {
        if (text == null) {
            return "";
        }
        // must replace amp first, so we dont replace &lt; to amp later
        text = text.replace("&", "&amp;");
        text = text.replace("\"", "&quot;");
        text = text.replace("<", "&lt;");
        text = text.replace(">", "&gt;");
        return text;
    }

}
<<<<<<<<DIVIDER>>>>>>>>
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;

import java.util.Objects;

/**
 * Holder for a key and value.
 */
public class KeyValueHolder<K, V> {

    private final K key;
    private final V value;

    public KeyValueHolder(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey() {
        return key;
    }

    public V getValue() {
        return value;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        KeyValueHolder<?, ?> that = (KeyValueHolder<?, ?>) o;
        return Objects.equals(key, that.key)
                && Objects.equals(value, that.value);
    }

    @Override
    public int hashCode() {
        return Objects.hash(key, value);
    }

    @Override
    public String toString() {
        return key + " -> " + value;
    }
}
<<<<<<<<DIVIDER>>>>>>>>
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.tooling.model;

/**
 * Some String helper methods
 */
public final class Strings {

    private Strings() {
        //Helper class
    }

    /**
     * Returns true if the given text is null or empty string or has <var>null</var> as the value
     */
    public static boolean isNullOrEmpty(String text) {
        return text == null || text.isEmpty() || "null".equals(text);
    }

    public static String cutLastZeroDigit(String version) {
        String answer = version;
        // cut last digit so its not 2.18.0 but 2.18
        String[] parts = version.split("\\.");
        if (parts.length == 3 && parts[2].equals("0")) {
            answer = parts[0] + "." + parts[1];
        }
        return answer;
    }

    /**
     * To wrap long camel cased texts by words.
     *
     * @param option    the option which is camel cased.
     * @param watermark a watermark to denote the size to cut after
     * @param lineSep   the new line to use when breaking into a new line
     */
    public static String wrapCamelCaseWords(String option, int watermark, String lineSep) {
        String text = option.replaceAll("(?=[A-Z][a-z])", " ");
        text = wrapWords(text, "", lineSep, watermark, false);
        text = Character.toUpperCase(text.charAt(0)) + text.substring(1);
        if (text.startsWith(lineSep)) {
            text = text.substring(lineSep.length());
        }
        if (text.endsWith(lineSep)) {
            text = text.substring(0, text.length() - lineSep.length());
        }
        return text;
    }

    /**
     * To wrap a big line by words.
     *
     * @param line          the big line
     * @param wordSep       the word separator
     * @param lineSep       the new line to use when breaking into a new line
     * @param watermark     a watermark to denote the size to cut after
     * @param wrapLongWords whether to wrap long words
     */
    public static String wrapWords(String line, String wordSep, String lineSep, int watermark, boolean wrapLongWords) {
        if (line == null) {
            return null;
        } else {
            if (lineSep == null) {
                lineSep = System.lineSeparator();
            }
            if (wordSep == null) {
                wordSep = "";
            }

            if (watermark < 1) {
                watermark = 1;
            }

            int inputLineLength = line.length();
            int offset = 0;
            StringBuilder sb = new StringBuilder(inputLineLength + 32);
            int currentLength = 0;
            while (offset < inputLineLength) {
                if (line.charAt(offset) == ' ') {
                    offset++;
                    continue;
                }
                int next = line.indexOf(' ', offset);
                if (next < 0) {
                    next = inputLineLength;
                    if (wrapLongWords && inputLineLength - offset > watermark) {
                        if (currentLength > 0) {
                            sb.append(wordSep);
                            currentLength += wordSep.length();
                        }
                        sb.append(line, offset, watermark - currentLength);
                        sb.append(lineSep);
                        offset += watermark - currentLength;
                    }
                }
                if (currentLength + (currentLength > 0 ? wordSep.length() : 0) + next - offset <= watermark) {
                    if (currentLength > 0) {
                        sb.append(wordSep);
                        currentLength += wordSep.length();
                    }
                    sb.append(line, offset, next);
                    currentLength += next - offset;
                    offset = next + 1;
                } else {
                    sb.append(lineSep);
                    sb.append(line, offset, next);
                    currentLength = next - offset;
                    offset = next + 1;
                }
            }
            return sb.toString();
        }
    }

    /**
     * Returns the base class name, i.e. without package and generic related information.
     *
     * @param  className The class name which base class is to be computed.
     * @return           the base class name, i.e. without package and generic related information.
     */
    public static String getClassShortName(String className) {
        if (className != null) {
            return className.replaceAll("<.*>", "").replaceAll(".*[.]([^.]+)", "$1");
        }
        return className;
    }
}
<<<<<<<<DIVIDER>>>>>>>>
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;

import java.util.concurrent.Future;

import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.WrappedFile;
import org.apache.camel.support.TypeConverterSupport;

/**
 * A simple converter that can convert any object to a String type by using the toString() method of the object.
 */
public class ToStringTypeConverter extends TypeConverterSupport {

    @SuppressWarnings("unchecked")
    @Override
    public <T> T convertTo(Class<T> toType, Exchange exchange, Object value) {

        // should not try to convert these specific types
        if (value instanceof Message || value instanceof WrappedFile || value instanceof Future) {
            return (T) MISS_VALUE;
        }

        if (toType.equals(String.class)) {
            return (T) value.toString();
        }
        return null;
    }

}
